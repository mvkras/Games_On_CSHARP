using System;
using System.Collections.Generic;
using System.Text;

namespace B_Tic_Tac_Toe.Tic_Tac_Toe_Game
{
    public  enum State 
    {
        none,
        Cross,
        Zero
    }
    public enum Winner //когда клиентский код запрашивает победителя: варианты
    {
        Crosses,  //победили крестики
        Zeroes,  //победили нолики
        Draw,    //ничья
        GameIsUnfinished //игра не закончена
    }
    public class TicTacToe_Game //создадик класс, где будет логика игры
    {
        //нужно заявить массив состояния клеток, заявим еще для этого перечисления
        //перечисления, так как может быть несколько состояний клетки: (пустая клетка, крестик, нолик)
        private readonly State[] board = new State[9]; //создали экземпляр 9 клеток, т.к мы играем 3 на 3
        public int moveCounter { get; private set; } //создали свойство для трекинга (счетчика)
        public TicTacToe_Game() //нужно проинициализировать нашу доску и везде поставить статус none
        {
            for (int i = 0; i < board.Length; i++)
            {
                board[i] = State.none; //по умолчанию клетки будут пустыми
            }
            //Первый игрок, который начинает ходить, он ставит крестики первыми
            //Для того, чтобы определять, кто сейчас ходит, заведем счетчик ходов
            //Когда счетчик четный(0, 2, 4, 6) - будут ставиться крестики, нечетные(1, 3, 5, 7) - нолики
            //Так же необходимо проверить закончилась игра или еще нет.
        }
       
        //Выкатим метод, чтобы клиентский код мог делать ход
        public void MakeMove(int index) //индекс от 1 до 9
        {
            //будем выводить текущее состояние доски, где не проставлено крестик или нолик - выводить индекс от 1 до 9(включительно)
            //будем проставлять крестики и нолики, используя смещение на 1
            board[index - 1] = moveCounter % 2 == 0 ? State.Cross : State.Zero; //четные - ставим крестик, иначе нолик
            moveCounter++; //увеличили ход
        }

        //Метод который будет показывать состояние клетки по индексу
        public State GetState(int index)
        {
            return board[index - 1];
        }

        //Так же нам необходимо, чтобы клиентский код мог определять победителя
        //выйгрышная комбинация:   
        //1 2 3  все вертикали,
        //4 5 6  все горисонтали
        //7 8 9  и 2 диагонали 
        
        //Создадим приватный метод, где реализуем всю логику, а в него как раз передать все возможные победные тройки
        public Winner GetWinner() //будет возвращать перечисления
        {
            return GetWinner(1,4,7, 2,5,8, 3,6,9, //выйгрышные комбинации вертикали
                             1,2,3, 4,5,6, 7,8,9, //комбинации горизонтали
                             1,5,9, 7,5,3); //передаем триплеты, выйгрышные комбинации диагонали
        }
        //Сгенерировали метод выйгрышних комбинаций
        //Создадим приватный метод, где реализуем всю логику, а в него как раз передать все возможные победные тройки
        private Winner GetWinner(params int[] indexes)
        {
            //запустим цикл for и будем инкрементировать по 3, чтобы идти по триплетам
            for (int i = 0; i < indexes.Length; i+=3)
            {
                //нам необходимо проверить, что в indexes[i] 1 и  indexes[i] 2 находится 1 и тот же значек
                bool same = areSame(indexes[i], indexes[i + 1], indexes[i+2]); //1, 4, 7 там где indexes[i+1]. Итерация встанет уже 2, 5, 8
                //будем идти по 3кам
                if(same) //если true
                {
                    //Нам нужно хотябы 1 из State проверить, что он не пустой, Чтобы не было все 3 поля пустых                   
                    State state = GetState(indexes[i]); //можем взять одно из них и проверить, что не пустое
                    
                    //объявим победителя таким образом
                    if(state != State.none)
                    {
                        return state == State.Cross ? Winner.Crosses : Winner.Zeroes; //кто выйграл
                    }
                }    
            }
            //Если победителя нет
            if(moveCounter < 9)
            {
                return Winner.GameIsUnfinished; //игра не закончена
            }
            //в противном случае
            return Winner.Draw; //ничья
        }
        //создадим вспомогательный метод для этого
        private bool areSame(int a, int b, int c) //будет принимать 3 поля
        {
            //будет опираться на наш метод GetState будет проверять статус этих триплетов
            return GetState(a) == GetState(b) && GetState(a) == GetState(c); //если везде State совпадает. То он возвращает true
        }

        
    }
}
