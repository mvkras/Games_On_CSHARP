using B_Tic_Tac_Toe.Tic_Tac_Toe_Game;
using System;
using System.Text;

namespace B_Tic_Tac_Toe
{
    class Program //Крестики нолики
    {
        //статические члены не будут иметь доступ к нестатическим
        private static TicTacToe_Game g = new TicTacToe_Game();
        static void Main(string[] args)
        {
            Console.WriteLine(GetPrintState()); //пустое поле
            //запустим цикл
            while (g.GetWinner() == Winner.GameIsUnfinished ) //пока игра не окончена - мы продолжаем игру
            {
                int index = int.Parse(Console.ReadLine()); //получили индекс
                g.MakeMove(index); // передаем индекс туда 
               
                Console.WriteLine(); //отступ строки
                Console.WriteLine(GetPrintState()); //выводим текущее состояние
            }
            Console.WriteLine($"Выиграл - {g.GetWinner()}"); //когда игра закончилась
        }

        /* Вы попробуете реализовать игру в крестики-нолики размером 3х3 - самые что ни наесть обыкновенные.
           Сделайте метод, который выводит на каждом ходу текущее положение с линейками, крестиками и ноликами 
           (используйте буквы X и O в качестве крестиков и ноликов) - так игрокам будет удобнее ориентироваться.

            Также вам понадобится реализовать способ проверки наличия выигрышной комбинации. 
            Подсказа: договоримся, что клетки поля будут пронумерованы 
            от 0 до 8 и пользователи будут вводить индекс поля, чтобы поставить там крестик или нолик.
             Для упрощения - тот кто ходит первым - ставит крестик.
        
         * В ходе реализации этой игры будут 2 логики: логическая и клиентская
         */

        //организовываем клиентскиую часть Необходим вспомогательный метод для красивого вывода текущего состояния нашей доски
        static string GetPrintState()
        {
            //воспользуемся StringBuilder
            StringBuilder sb = new StringBuilder(); //чтобы создать конечную строку
            //попробуем в 3 итерации сформировать наше поле
           
            
            //на каждой итерации будем брать состояние i-того поля, i + 1, i + 2
            for (int i = 1; i <= 7; i+= 3) // 7 т.к нам нужно всего 2 инкремента. Возьмем состояние 7 => 8 и 9 тоже возьмем
            {                              //дальше нет смысла идти
               
                sb.AppendLine("     |     |     |") //каждое поле обрамим вертикальными черточками
                  .AppendLine( //т.к возвращает модифицированный StringBuilder
                   $"  {GetPrintChar(i)}  |  {GetPrintChar(i + 1)}  |  {GetPrintChar(i + 2)}  |")  //вызовем еще 1 метод, будет возвращать X или O либо индекс
                   .AppendLine("_____|_____|_____|");
            }
            return sb.ToString(); //Возвращаем стринговую репрезентацию стринг билдера
        }
        
        static string GetPrintChar(int index)
        {
            State state = g.GetState(index); //запрашивать будет состояние
            if(state == State.none)
            {
                return index.ToString(); //возвращаем само число в стринговой репрезентации
            } //чтобы пользователь видел индексы, где пустые клетки
            return state == State.Cross ? "X" : "O"; //возвращаем крестик, либо О
        }
    }
}
